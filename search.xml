<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[纯代码实现侧边栏显示社交按钮组]]></title>
    <url>%2Fposts%2F5508299d%2F</url>
    <content type="text"><![CDATA[其实想要实现这个功能也是挺简单的，有两种办法! 方法1： 纯html代码实现(优点：添加很简单，只需把html代码粘贴到小工具中的文本中即可。缺点：更改相对麻烦）把下面内容改成自己的。 12345678&lt;div class="textwidget"&gt;&lt;a class="tweibo" style="padding-left: 12px;" href="http://wpa.qq.com/msgrd?v=3&amp;amp;uin=你的QQ号&amp;amp;site=qq&amp;amp;menu=yes" target="_blank" rel="external nofollow"&gt;&lt;i class="fa fa-qq"&gt;&lt;/i&gt; 在线服务&lt;/a&gt;&lt;a class="tweibo" style="padding-left: 12px;" href="http://weibo.com/你的微博" target="_blank" rel="external nofollow"&gt;&lt;i class="fa fa-weibo"&gt;&lt;/i&gt; 微博&lt;/a&gt;&lt;a class="tweibo" style="padding-left: 12px;" href="http://t.qq.com/你的企鹅微博" target="_blank" rel="external nofollow"&gt;&lt;i class="fa fa-tencent-weibo"&gt;&lt;/i&gt; 腾讯微博&lt;/a&gt;&lt;a class="rss" style="padding-left: 12px;" href="https://laod.cn/go?url=http://laid.cn/s/你的网址" target="_blank"&gt;&lt;i class="fa fa-paw"&gt;&lt;/i&gt; 百度口碑&lt;/a&gt;&lt;/div&gt; 方法2： 通过funtions增加自定义用户资料，然后通过函数调用。 先加代码到当前主题文件夹下的funtions.php中，代码如下： 12345678//自定义用户资料add_filter( 'user_contactmethods', 'yeziting_add_contact_fields' );function yeziting_add_contact_fields( $contactmethods ) &#123;$contactmethods['qq'] = 'QQ';$contactmethods['qq_weibo'] = '腾讯微博';$contactmethods['sina_weibo'] = '新浪微博';$contactmethods['donate'] = '百度口碑';&#125; 然后再加代码到sidebar.php文件中。代码如下。（修改的话直接进后台的个人资料中填写。QQ直接写QQ号即可。微博：http://weibo.com/你的微博地址。腾讯微博同样如此，百度口碑写自己的网址即。 12345&lt;div class="textwidget"&gt;&lt;a class="tweibo" style="padding-left: 12px;" href="http://wpa.qq.com/msgrd?v=3&amp;amp;uin=&amp;lt;?php the_author_meta( 'qq' );?&amp;gt;&amp;amp;site=qq&amp;amp;menu=yes" target="_blank" rel="external nofollow"&gt;&lt;i class="fa fa-qq"&gt;&lt;/i&gt; QQ交谈&lt;/a&gt; &lt;a class="tweibo" style="padding-left: 12px;" href="&amp;quot;http://weibo.com/&amp;lt;?php"&gt;"target="_blank" rel="external nofollow"&amp;gt;&lt;i class="fa fa-weibo"&gt;&lt;/i&gt; 微博&lt;/a&gt; &lt;a class="tweibo" style="padding-left: 12px;" href="http://t.qq.com/&amp;lt;?php the_author_meta( 'qq_weibo' );?&amp;gt;" target="_blank" rel="external nofollow"&gt;&lt;i class="fa fa-tencent-weibo"&gt;&lt;/i&gt; 腾讯微博&lt;/a&gt; style="padding-left: 12px;" href="http://koubei.baidu.com/s/&lt;!--?php the_author_meta( 'donate' );?--&gt;" target="_blank"&amp;gt;&lt;i class="fa fa-paw"&gt;&lt;/i&gt; 百度口碑&lt;/div&gt; CSS代码： 12345678910.textwidget &#123;padding: 15px;color: #777;&#125;.textwidget a &#123;color: #777;&#125;.textwidget a:hover &#123;color: #45B6F7;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>按钮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo seo优化]]></title>
    <url>%2Fposts%2Ffe6afcc5%2F</url>
    <content type="text"><![CDATA[Next主题自带SEO优化选项hexo博客next提供了seo优化选项，在主题配置文件_config.yml中有个选项是seo，默认是false，改成true即开启了seo优化，会进行一些seo优化，如改变博文title等，然后相同文件下有个关键字选项keywords，填充上，写博文时最好每篇博文都加上keywords。hexo的根目录配置文件_config.yml中title、subtitle和description也建议填上。开启seo优化后可以查看网页源码跟之前有什么不同。 文章标题转换唯一链接使用插件hexo-abbrlink可以做到，安装： 1$ npm install hexo-abbrlink --save 然后hexo的根目录配置文件_config.yml中修改： 1234permalink: :abbrlink/abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex 这样就确保了博文链接的唯一化，只要不修改md文件的abbrlink的值，url就永久不会改变。如此md文件名和文件内容也可以随便改了。这样也有利于SEO优化。 给出站链接添加 “nofollow” 标签nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。 Hexo 的 Next 主题需要改以下几个地方： 找到footer.swig，路径在your-hexo-site\themes\next\layout\_partials，将下面代码中的a标签加上rel=&quot;external nofollow&quot;属性； 1&#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="http://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125; 1&lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next"&gt; 修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码中的a标签加上rel=&quot;external nofollow&quot;属性；1&lt;a href="&#123;&#123; link &#125;&#125;" target="_blank"&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt; 1&lt;a href="http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0" class="cc-opacity" target="_blank"&gt; 让百度收录你的站点我们首先要做的就是让各大搜索引擎收录你的站点，我们在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入site:&lt;域名&gt;,来看我们的网站有没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站. 登录百度站长平台，只要有百度旗下的账号就可以登录，登录成功之后在站点管理中点击添加网站然后输入你的站点地址，建议输入的网站为www开头的，不要输入github.io的，因为github是不允许百度的spider爬取github上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名。或者用国内的coding。 选择完网站的类型之后需要验证网站的所有权，验证网站所有权的方式有三种：文件验证、html标签验证、cname解析验证。注意：使用文件验证文件存放的位置需要放在source文件夹下，如果是html文件那么hexo就会将其编译，所以必须要加上的layout:false，这样就不会被hexo编译。（如果验证文件是txt格式的就不需要），其他两种方式也是很简单的。我个人推荐文件验证和cname验证，cname验证最为简单，只需加一条解析就好~ 给站点添加sitemap我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎 安装sitemap插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在站点配置文件_config.yml中添加以下代码12345# 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 修改站点配置文件_config.yml123# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite Hexo编译12hexo cleanhexo g 生成sitemap.xml和baidusitemap.xml，重启hexo通过http://localhost:4000/baidusitemap.xml和http://localhost:4000/sitemap.xml查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。 提交sitemap到站长平台有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap. 如何选择链接提交方式主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。 自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。 sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。 手动提交：一次性提交链接给百度，可以使用此种方式。 从效率上来：主动推送&gt;自动推送&gt;sitemap 主动推送安装插件 1npm install hexo-baidu-url-submit --save 然后再根目录的配置文件中新增字段 12345baidu_url_submit: count: 100 # 提交最新的一个链接 host: www.cherryblog.site # 在百度站长平台中注册的域名 token: 8OGYpxowYnhgVsUM # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里 在加入新的deploye 12deploy: - type:baidu_url_submitter 这样执行hexo deploy的时候，新的链接就会被推送了 自动推送在主题配置文件下设置,将baidu_push设置为true： 12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true 然后就会将一下代码自动推送到百度，位置是themes\next\layout_scripts\baidu_push.swig,这样每次访问博客中的页面就会自动向百度提交sitemap 12345678910111213141516&#123;% if theme.baidu_push %&#125;&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt;&#123;% endif %&#125; 添加蜘蛛协议 robots新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下123456789101112# hexo robots.txtUser-agent: * Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: 域名/sitemap.xmlSitemap: 域名/baidusitemap.xml 然后去百度站长平台检测robots文件看看有没有生效 hexo目录结构默认目录结构：1234567891011.├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录 drafts：草稿文章 posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 主题结构： 12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 域名解析 git A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上. 解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址 在自己的Hexo\source目录下创建一个CNAME文件，打开后，里面写入自己的域名地址，如：www.xxxxx.com hexo-wordcount阅读时长安装wordcount插件 1npm install hexo-wordcount --save 主要功能：字数统计:WordCount阅读时长预计:Min2Read总字数统计: TotalCount 安装完插件之后在主题的配置文件中开启该功能就可以~,如果仅仅只是打开开关，部署之后会发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等字样，只有光秃秃的数字在那里. 解决方案 找到Blog\themes\next\layout\_macro\post.swig 文件 字数统计 123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt; 123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字 &lt;/span&gt; 阅读时长 123&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; &lt;/span&gt; 添加 “分钟”到min2read(post.content) }} 后面，修改后为： 123&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟 &lt;/span&gt; 添加 “字”到wordcount(post.content) }} 后面，修改后为： 再次运行，就能得到正常的如“字数统计 100字”“阅读时长 6分钟”这样的样式了 添加动态titile —崩溃欺骗新建js文件并添加如下代码，放在\themes\next\source\js\src文件目录下引用 1234567891011121314151617&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/TEP.ico"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~ | 量子广告！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/favicon.ico"); document.title = '(ฅ&gt;ω&lt;*ฅ) 噫又好了~' + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;);]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3实现图片木桶布局]]></title>
    <url>%2Fposts%2F6eb4240a%2F</url>
    <content type="text"><![CDATA[思路： 1、容器flex布局 2、图片定高、超出换行 3、图片都设置 flex-grow: 1; 以充满整行 4、图片都设置 object-fit: cover; 以解决图片变形 5、容器 :after 伪类 设置 flex-grow: 9999; 且值足够高 以解决最后一行图片数量少时仍然充满整行过于扁长 实现效果： html代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt; &lt;script&gt; window.navigator.appVersion.indexOf('Trident') != -1 &amp;&amp; alert('请用谷歌或火狐新版打开！'); &lt;/script&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0; &#125; body&#123; padding: 50px 0; overflow-x: hidden; &#125; .wrap&#123; display: flex; flex-wrap: wrap; &#125; .wrap img&#123; margin: 3px; padding: 5px; height: 200px; background: #ccc; flex-grow: 1; object-fit: cover; transition: .3s; &#125; .wrap:after&#123; display: block; content: ''; flex-grow: 9999; &#125; .wrap img:hover&#123; transform: scale(1.2); box-shadow: 0 0 20px #fff; z-index: 9999; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="wrap"&gt;&lt;/div&gt; &lt;script&gt; var wrap = document.querySelector('.wrap'); var src = ['//cdn.attach.qdfuns.com/notes/pics/201710/13/093715yf2jt47tttj9lyfj.jpg','//cdn.attach.qdfuns.com/notes/pics/201710/13/092835ebbkfzjtb4okwj2b.jpg','//cdn.attach.qdfuns.com/notes/pics/201710/13/092835beqzk6kyjkbwr5bw.jpg','//cdn.attach.qdfuns.com/notes/pics/201710/13/092835nshkii0i2k0dsikn.jpg','//cdn.attach.qdfuns.com/notes/pics/201710/13/093653k6ztcd7x7czebkfh.jpg'] for(var i=0; i&lt;Math.floor(Math.random()*10+30); i++)&#123; var img = document.createElement('img'); img.src = src[Math.floor(Math.random()*5)]; wrap.appendChild(img); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css3,布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css小细节总结]]></title>
    <url>%2Fposts%2Fb565c126%2F</url>
    <content type="text"><![CDATA[max-width 来防止图片撑破容器1234 img &#123; display:inline-block; max-width: 100%;&#125; pointer-event 来禁用事件,该属性可以做以下事：阻止任何点击动作的执行;使链接显示为默认光标（cursor:default）;阻止触发hover和active状态;阻止JavaScript点击事件的触发; 12//使用该类，任何点击事件将无效.disabled &#123; pointer-events: none; &#125; overflow 来清楚浮动overflow除了定义溢出元素内容区的内容会如何处理外，还可以创建块格式化上下文，清除浮动。 1234&lt;div class="clearfix"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 123.clearfix &#123; overflow: hidden;&#125; user-select 来禁用文本选中IE6-9不支持该属性，可以通过给body添加onselectstart=&quot;return false;&quot;的内联JavaScript语句搞定。 123body&#123; user-select: none; //页面中的文本不能被选中&#125; caret-color 来自定义光标的样式123input,textarea,[contenteditable] &#123; caret-color: red;&#125; table-layout 来控制表格单元格宽度,由于表格单元格的宽度根据其内容进行调整，也许你设置了表格的宽度，但是不起作用；刨根揭底，是因为表格有个叫做table-layout的属性，其浏览器默认值是auto在作怪。当我们把这个值设置为fixed的时候，给th/td标签设置的宽度就起作用了。 1234table &#123; table-layout: fixed; width: 100%;&#125; :valid :invalid 来做表单及时验证.:required 伪类指定具有required 属性的表单元素;:valid 伪类指定一个通过匹配正确的所要求的表单元素;:invalid 伪类指定一个不匹配指定要求的表单元素; 12345678910111213141516171819202122&lt;div class="container"&gt; &lt;div class="row" style="margin-top: 2rem;"&gt; &lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;name&lt;/label&gt; &lt;input type="text" required placeholder="请输入名称"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;email&lt;/label&gt; &lt;input type="email" required placeholder="请输入邮箱"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;homepage&lt;/label&gt; &lt;input type="url" placeholder="请输入博客url"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Comments&lt;/label&gt; &lt;textarea required&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; 12345678910111213141516171819202122232425262728293031.form-group &#123; width: 32rem; padding: 1rem; border: 1px solid transparent;&#125;.form-group：hover&#123; border-color: #eee; transition: border .2s;&#125;.form-group label &#123; display: block; font-weight: normal;&#125;.form-group input,.form-group textarea &#123; display: block; width: 100%; line-height: 2rem; padding: .5rem .5rem .5rem 1rem; border: 1px solid #ccc; outline: none;&#125;.form-group input:valid ,.form-group textarea:valid &#123; border-color: #429032; box-shadow: inset 5px 0 0 #429032;&#125;.form-group input:invalid ,.form-group textarea:invalid &#123; border-color: #D61D1D; box-shadow: inset 5px 0 0 #D61D1D;&#125; :target 来实现折叠面板1234567891011121314151617181920212223&lt;div class="container"&gt; &lt;div class="row" style="margin-top: 2rem;"&gt; &lt;div class="t-collapse"&gt;&lt;a class="collapse-target" href="#modal1"&gt;target 1&lt;/a&gt; &lt;div class="collapse-body" id="modal1"&gt; &lt;a class="collapse-close" href="#"&gt;target 1&lt;/a&gt; &lt;p&gt; css3 明确规定了伪类用一个冒号:来表示，而伪元素则用两个冒号::来表示。 伪类更多的定义的是状态，如:hover，或者说是一个可以使用CSS进行修饰的特定的特殊元素，如:first-child 常见伪类：:hover :active :focus :visited :link :lang :first-child :last-child :not &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="t-collapse"&gt;&lt;a class="collapse-target" href="#modal2"&gt;target 2&lt;/a&gt; &lt;div class="collapse-body" id="modal2"&gt; &lt;a class="collapse-close" href="#"&gt;target 2&lt;/a&gt; &lt;p&gt; 伪元素简单来说就是不存在于DOM文档树中的虚拟的元素，它们和HTML元素一样，但是你又无法使用JavaScript去获取，如:before 常见伪元素：::before ::after ::first-letter ::first-line &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738.t-collapse &#123; border: 1px solid #ccc; margin-top: -1px; &amp;:first-child &#123; margin-top: 0; &#125; .collapse-target,.collapse-close &#123; cursor: pointer; height: 3rem; line-height: 2rem; padding: .5rem 2rem; text-decoration: none; user-select: none; background: #eee; &#125; &gt;.collapse-target &#123; display: block; &#125; &gt;.collapse-body &#123; position: relative; display: none; padding: 2rem; .collapse-close &#123; display: none; position: absolute; top: -3rem; width: 100%; left: 0; &#125; &amp;:target &#123; display: block; .collapse-close &#123; display: block; border-bottom: 1px solid #ddd; &#125; &#125; &#125;&#125; :not 来排除其他选择器用以设置表单元素在readonly 和 disabled状态之外的hover等状态，以便于当元素在readonly 和 disabled时，元素不具有hover状态。 12345678910111213@mixin buttonStyle ($border, $background, $color, $hoverBorder, $hoverBackground, $hoverColor) &#123; color: $color; border-color: $border; background-color: $background; &amp;:not(.readonly):not([readonly]):not(.disabled):not([disabled]) &#123; &amp;:hover, &amp;:active &#123; color: $hoverColor; border-color: $hoverBorder; background-color: $hoverBackground; &#125; &#125;&#125; :nth-child(even/odd) 来实现隔行变色123456789101112ul &#123; &amp;.odd &#123; &gt;li:nth-child(odd) &#123; background: red; &#125; &#125; &amp;.even &#123; &gt;li:nth-child(even) &#123; background: green; &#125; &#125;&#125; ::selection 来美化选中文本1234::selection&#123; color: #fff; background-color: #6bc30d;&#125; ::placeholder 来美化占位符123456789input::-webkit-input-placeholder&#123; color: #f00;&#125;input::-moz-placeholder&#123; color: #f00;&#125;input:-ms-input-placeholder&#123; color: #f00;&#125; ::first-letter 来实现段落首字下沉12345p::first-letter&#123; font-size: 6em; line-height: 1; float: left;&#125; ::first-line 来特殊标记段落第一行123p::first-line&#123; color: red&#125; font-size:0 来清除间距123456&lt;div class="items"&gt; &lt;div class="item"&gt;1&lt;/div&gt; &lt;div class="item"&gt;2&lt;/div&gt; &lt;div class="item"&gt;3&lt;/div&gt; &lt;div class="item"&gt;4&lt;/div&gt;&lt;/div&gt; 12345678910111213141516*&#123; box-sizing: border-box;&#125;.items &#123; font-size: 0; &gt; .item &#123; display: inline-block; width: 25%; height: 50px; border: 1px solid #ccc; text-align: center; line-height: 50px; background-color: #eee; font-size: 16px; //不要忘了给子元素设置字号 &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
</search>
